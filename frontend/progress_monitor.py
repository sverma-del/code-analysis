# Code Generated by Sidekick is for learning and experimentation purposes only.
import streamlit as st
import websocket
import json
import threading
import time

class ProgressMonitor:
    """
    WebSocket-based progress monitor for real-time updates
    """
    def __init__(self, project_id):
        self.project_id = project_id
        self.ws = None
        self.events = []
        self.connected = False
        self.thread = None
        
    def connect(self):
        """Connect to WebSocket"""
        try:
            ws_url = f"ws://localhost:8000/progress/ws/{self.project_id}"
            self.ws = websocket.WebSocketApp(
                ws_url,
                on_message=self.on_message,
                on_error=self.on_error,
                on_close=self.on_close,
                on_open=self.on_open
            )
            
            # Run in background thread
            self.thread = threading.Thread(target=self.ws.run_forever)
            self.thread.daemon = True
            self.thread.start()
            
        except Exception as e:
            st.error(f"WebSocket connection error: {e}")
    
    def on_open(self, ws):
        self.connected = True
        print(f"WebSocket connected for project {self.project_id}")
    
    def on_message(self, ws, message):
        try:
            data = json.loads(message)
            self.events.append(data)
            print(f"Progress event: {data.get('type')} - {data.get('message')}")
        except json.JSONDecodeError:
            print(f"Invalid JSON message: {message}")
    
    def on_error(self, ws, error):
        print(f"WebSocket error: {error}")
    
    def on_close(self, ws, close_status_code, close_msg):
        self.connected = False
        print(f"WebSocket closed")
    
    def disconnect(self):
        if self.ws:
            self.ws.close()
    
    def get_events(self):
        return self.events
    
    def get_latest_event(self):
        return self.events[-1] if self.events else None


def render_progress_feed(events, max_display=20):
    """
    Render progress events as a feed
    """
    if not events:
        st.info("Waiting for analysis to start...")
        return
    
    # Show latest events first
    display_events = list(reversed(events[-max_display:]))
    
    for event in display_events:
        event_type = event.get('type', 'info')
        message = event.get('message', '')
        details = event.get('details', {})
        agent = event.get('agent_name', '')
        percentage = event.get('percentage', 0)
        
        # Icon based on event type
        icon_map = {
            'milestone': 'üéØ',
            'processing': '‚öôÔ∏è',
            'agent_start': 'ü§ñ',
            'agent_end': '‚úÖ',
            'web_search': 'üåê',
            'warning': '‚ö†Ô∏è',
            'error': '‚ùå',
            'info': '‚ÑπÔ∏è'
        }
        
        icon = icon_map.get(event_type, '‚Ä¢')
        
        # Color based on event type
        color_map = {
            'milestone': '#28a745',
            'processing': '#17a2b8',
            'agent_start': '#ffc107',
            'agent_end': '#28a745',
            'web_search': '#007bff',
            'warning': '#ffc107',
            'error': '#dc3545',
            'info': '#6c757d'
        }
        
        color = color_map.get(event_type, '#6c757d')
        
        # Render event
        agent_text = f" | {agent}" if agent else ""
        
        st.markdown(f"""
        <div style="border-left: 4px solid {color}; padding: 10px; margin: 5px 0; background: #f8f9fa;">
            <strong>{icon} {message}</strong>{agent_text}
            <div style="font-size: 0.85em; color: #6c757d; margin-top: 5px;">
                Progress: {percentage:.1f}% | {event.get('current_step', 0)}/{event.get('total_steps', 0)}
            </div>
        </div>
        """, unsafe_allow_html=True)
