# Code Generated by Sidekick is for learning and experimentation purposes only.
from typing import TypedDict, Annotated, Sequence
from langgraph.graph import StateGraph, END
from langchain_openai import ChatOpenAI
from models.projects import Project
from models.progress import AnalysisConfig
from services.progress_manager import ProgressManager, get_progress_manager
from services.web_search import get_web_search
from services.agents.dependency_agent import build_dependency_graph
from services.agents.api_agent import extract_api_endpoints
from services.agents.architecture_agent import analyze_architecture
from services.agents.database_agent import analyze_database_schema
from services.agents.security_agent import analyze_security
from services.agents.setup_agent import generate_setup_instructions
import operator


class AgentState(TypedDict):
    """
    State shared between all agents
    ✅ FIXED: Only annotate fields that multiple agents write to
    """
    # Shared read-only objects (not modified by agents)
    project_id: str  # ✅ Changed from Project object to ID
    config_id: str   # ✅ Changed from AnalysisConfig object to ID
    
    # Results from each agent (each agent writes to its own key)
    dependency_result: dict
    api_result: dict
    architecture_result: dict
    database_result: dict
    security_result: dict
    setup_result: dict
    
    # Web search results
    web_insights: list
    
    # Messages that multiple agents can append to
    messages: Annotated[list[str], operator.add]  # ✅ Uses reducer for concurrent updates


class LangGraphOrchestrator:
    """
    Orchestrates multiple agents using LangGraph
    """
    def __init__(self, project: Project, config: AnalysisConfig):
        self.project = project
        self.config = config
        self.progress = get_progress_manager(project)
        self.web_search = get_web_search()
        self.llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.3)
        
        # Build the graph
        self.graph = self._build_graph()
    
    def _build_graph(self) -> StateGraph:
        """
        Build the LangGraph workflow with SEQUENTIAL execution
        ✅ FIXED: Changed to sequential to avoid concurrent state updates
        """
        workflow = StateGraph(AgentState)
        
        # Define nodes (agents)
        workflow.add_node("coordinator", self.coordinator_agent)
        workflow.add_node("dependency_agent", self.dependency_agent)
        workflow.add_node("api_agent", self.api_agent)
        workflow.add_node("architecture_agent", self.architecture_agent)
        workflow.add_node("database_agent", self.database_agent)
        workflow.add_node("security_agent", self.security_agent)
        workflow.add_node("setup_agent", self.setup_agent)
        workflow.add_node("web_augmentation", self.web_augmentation_agent)
        workflow.add_node("synthesizer", self.synthesizer_agent)
        
        # ✅ FIXED: Sequential execution instead of parallel
        workflow.set_entry_point("coordinator")
        workflow.add_edge("coordinator", "dependency_agent")
        workflow.add_edge("dependency_agent", "api_agent")
        workflow.add_edge("api_agent", "architecture_agent")
        workflow.add_edge("architecture_agent", "database_agent")
        workflow.add_edge("database_agent", "security_agent")
        workflow.add_edge("security_agent", "setup_agent")
        
        # Web augmentation (if enabled)
        workflow.add_conditional_edges(
            "setup_agent",
            self.should_web_search,
            {
                True: "web_augmentation",
                False: "synthesizer"
            }
        )
        
        workflow.add_edge("web_augmentation", "synthesizer")
        workflow.add_edge("synthesizer", END)
        
        return workflow.compile()
    
    async def coordinator_agent(self, state: AgentState) -> AgentState:
        """
        Coordinates the analysis and sets up initial state
        """
        await self.progress.agent_start(
            "Coordinator",
            "Initializing analysis pipeline",
            {"depth": self.config.analysis_depth}
        )
        
        # Calculate total steps based on config
        total_steps = 6  # Base agents
        if self.config.enable_web_search:
            total_steps += 2
        
        self.progress.set_total_steps(total_steps)
        
        state["messages"].append("Analysis orchestration started")
        
        await self.progress.agent_end(
            "Coordinator",
            f"Ready to execute {total_steps} analysis steps"
        )
        
        return state
    
    async def dependency_agent(self, state: AgentState) -> AgentState:
        """
        Analyze code dependencies
        """
        await self.progress.agent_start(
            "Dependency Agent",
            "Mapping import relationships and dependencies"
        )
        
        result = await build_dependency_graph(self.project)
        state["dependency_result"] = {"edge_count": result}
        
        await self.progress.agent_end(
            "Dependency Agent",
            f"Discovered {result} dependency relationships",
            {"edge_count": result}
        )
        
        state["messages"].append(f"Dependency analysis complete: {result} edges")
        return state
    
    async def api_agent(self, state: AgentState) -> AgentState:
        """
        Extract and document API endpoints
        """
        await self.progress.agent_start(
            "API Agent",
            "Cataloging API endpoints and generating documentation"
        )
        
        result = await extract_api_endpoints(self.project)
        state["api_result"] = {"endpoint_count": result}
        
        await self.progress.agent_end(
            "API Agent",
            f"Documented {result} API endpoints",
            {"endpoint_count": result}
        )
        
        state["messages"].append(f"API catalog complete: {result} endpoints")
        return state
    
    async def architecture_agent(self, state: AgentState) -> AgentState:
        """
        Analyze system architecture
        """
        await self.progress.agent_start(
            "Architecture Agent",
            "Identifying components and architecture patterns"
        )
        
        result = await analyze_architecture(self.project)
        state["architecture_result"] = {"component_count": result}
        
        await self.progress.agent_end(
            "Architecture Agent",
            f"Identified {result} architectural components",
            {"component_count": result}
        )
        
        state["messages"].append(f"Architecture analysis complete: {result} components")
        return state
    
    async def database_agent(self, state: AgentState) -> AgentState:
        """
        Analyze database schema
        """
        await self.progress.agent_start(
            "Database Agent",
            "Extracting database models and relationships"
        )
        
        result = await analyze_database_schema(self.project)
        state["database_result"] = {"model_count": result}
        
        await self.progress.agent_end(
            "Database Agent",
            f"Mapped {result} database models",
            {"model_count": result}
        )
        
        state["messages"].append(f"Database schema complete: {result} models")
        return state
    
    async def security_agent(self, state: AgentState) -> AgentState:
        """
        Analyze security patterns
        """
        if not self.config.analyze_security:
            state["security_result"] = {"skipped": True}
            return state
        
        await self.progress.agent_start(
            "Security Agent",
            "Analyzing authentication and security patterns"
        )
        
        result = await analyze_security(self.project)
        state["security_result"] = {"finding_count": result}
        
        await self.progress.agent_end(
            "Security Agent",
            f"Identified {result} security patterns",
            {"finding_count": result}
        )
        
        state["messages"].append(f"Security analysis complete: {result} findings")
        return state
    
    async def setup_agent(self, state: AgentState) -> AgentState:
        """
        Generate setup instructions
        """
        await self.progress.agent_start(
            "Setup Agent",
            "Generating installation and setup guide"
        )
        
        result = await generate_setup_instructions(self.project)
        state["setup_result"] = {"generated": result}
        
        await self.progress.agent_end(
            "Setup Agent",
            "Setup instructions generated"
        )
        
        state["messages"].append("Setup guide complete")
        return state
    
    async def web_augmentation_agent(self, state: AgentState) -> AgentState:
        """
        Augment analysis with web search
        """
        await self.progress.agent_start(
            "Web Search Agent",
            "Searching for best practices and documentation"
        )
        
        insights = []
        
        # Search for framework best practices
        if self.project.detected_framework:
            await self.progress.web_search(
                f"{self.project.detected_framework} best practices",
                3
            )
            
            results = await self.web_search.search_framework_docs(
                self.project.detected_framework,
                "async patterns and best practices"
            )
            insights.extend(results)
        
        # Search for security guidelines if security analysis was done
        if state.get("security_result") and not state["security_result"].get("skipped"):
            await self.progress.web_search(
                "OWASP authentication security",
                3
            )
            
            results = await self.web_search.search_security_guidelines(
                "authentication implementation"
            )
            insights.extend(results)
        
        state["web_insights"] = insights
        
        await self.progress.agent_end(
            "Web Search Agent",
            f"Retrieved {len(insights)} external resources",
            {"insight_count": len(insights)}
        )
        
        state["messages"].append(f"Web augmentation complete: {len(insights)} insights")
        return state
    
    async def synthesizer_agent(self, state: AgentState) -> AgentState:
        """
        Synthesize all results into final report
        """
        await self.progress.agent_start(
            "Synthesizer",
            "Generating comprehensive analysis report"
        )
        
        # All agents have completed, create summary
        summary = {
            "dependencies": state.get("dependency_result", {}),
            "api": state.get("api_result", {}),
            "architecture": state.get("architecture_result", {}),
            "database": state.get("database_result", {}),
            "security": state.get("security_result", {}),
            "setup": state.get("setup_result", {}),
            "web_insights": len(state.get("web_insights", []))
        }
        
        await self.progress.milestone(
            "Analysis Complete",
            summary
        )
        
        await self.progress.agent_end(
            "Synthesizer",
            "Final report generated"
        )
        
        state["messages"].append("Analysis synthesis complete")
        return state
    
    def should_web_search(self, state: AgentState) -> bool:
        """
        Decide if web search should be performed
        """
        return self.config.enable_web_search
    
    async def run(self):
        """
        Execute the entire workflow
        """
        initial_state = {
            "project_id": str(self.project.id),
            "config_id": str(self.config.id),
            "dependency_result": {},
            "api_result": {},
            "architecture_result": {},
            "database_result": {},
            "security_result": {},
            "setup_result": {},
            "web_insights": [],
            "messages": []
        }
        
        # Run the graph
        final_state = await self.graph.ainvoke(initial_state)
        
        return final_state