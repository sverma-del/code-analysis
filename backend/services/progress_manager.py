# Code Generated by Sidekick is for learning and experimentation purposes only.
from models.progress import ProgressEvent, EventType
from models.projects import Project
from typing import Dict, List, Optional
import asyncio


class ProgressManager:
    """
    Manages progress tracking and broadcasting
    """
    def __init__(self, project: Project):
        self.project = project
        self.current_step = 0
        self.total_steps = 0
        self.listeners = []  # WebSocket connections will register here
    
    async def emit(
        self,
        event_type: EventType,
        message: str,
        details: Optional[Dict] = None,
        agent_name: Optional[str] = None,
        increment_step: bool = False
    ):
        """
        Emit a progress event
        """
        if increment_step:
            self.current_step += 1
        
        # Calculate percentage
        percentage = (self.current_step / self.total_steps * 100) if self.total_steps > 0 else 0
        
        # Save to database
        event = await ProgressEvent.create(
            project=self.project,
            event_type=event_type,
            message=message,
            details=details or {},
            current_step=self.current_step,
            total_steps=self.total_steps,
            percentage=percentage,
            agent_name=agent_name
        )
        
        # Broadcast to connected clients (WebSocket)
        await self.broadcast({
            "id": str(event.id),
            "type": event_type.value,
            "message": message,
            "details": details,
            "current_step": self.current_step,
            "total_steps": self.total_steps,
            "percentage": round(percentage, 2),
            "agent_name": agent_name,
            "timestamp": event.created_at.isoformat()
        })
        
        print(f"[Progress] [{event_type.value}] {message} ({self.current_step}/{self.total_steps})")
    
    async def broadcast(self, data: Dict):
        """
        Broadcast to all connected WebSocket clients
        """
        # Remove disconnected clients
        
        self.listeners = [client for client in self.listeners if not client.closed]
        
        # Send to all active clients
        for client in self.listeners:
            try:
                await client.send_json(data)
            except Exception as e:
                print(f"Error broadcasting to client: {e}")
    
    def register_listener(self, websocket):
        """
        Register a WebSocket connection for progress updates
        """
        self.listeners.append(websocket)
    
    def set_total_steps(self, total: int):
        """
        Set the total number of steps for progress calculation
        """
        self.total_steps = total
    
    async def milestone(self, message: str, details: Optional[Dict] = None):
        """
        Emit a milestone completion event
        """
        await self.emit(EventType.MILESTONE, message, details)
    
    async def processing(self, message: str, details: Optional[Dict] = None, increment: bool = True):
        """
        Emit a file processing event
        """
        await self.emit(EventType.PROCESSING, message, details, increment_step=increment)
    
    async def warning(self, message: str, details: Optional[Dict] = None):
        """
        Emit a warning event
        """
        await self.emit(EventType.WARNING, message, details)
    
    async def error(self, message: str, details: Optional[Dict] = None):
        """
        Emit an error event
        """
        await self.emit(EventType.ERROR, message, details)
    
    async def info(self, message: str, details: Optional[Dict] = None):
        """
        Emit an info event
        """
        await self.emit(EventType.INFO, message, details)
    
    async def agent_start(self, agent_name: str, message: str, details: Optional[Dict] = None):
        """
        Emit agent start event
        """
        await self.emit(EventType.AGENT_START, message, details, agent_name=agent_name)
    
    async def agent_end(self, agent_name: str, message: str, details: Optional[Dict] = None):
        """
        Emit agent completion event
        """
        await self.emit(EventType.AGENT_END, message, details, agent_name=agent_name)
    
    async def web_search(self, query: str, results_count: int):
        """
        Emit web search event
        """
        await self.emit(
            EventType.WEB_SEARCH,
            f"Searching documentation: {query}",
            {"query": query, "results_count": results_count}
        )


# Global registry of progress managers by project_id
_progress_managers: Dict[str, ProgressManager] = {}


def get_progress_manager(project: Project) -> ProgressManager:
    """
    Get or create a progress manager for a project
    """
    project_id = str(project.id)
    
    if project_id not in _progress_managers:
        _progress_managers[project_id] = ProgressManager(project)
    
    return _progress_managers[project_id]


def cleanup_progress_manager(project_id: str):
    """
    Remove progress manager after analysis completes
    """
    if project_id in _progress_managers:
        del _progress_managers[project_id]
