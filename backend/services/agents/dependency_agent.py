# Code Generated by Sidekick is for learning and experimentation purposes only.
from models.projects import Project, FileMetadata
from models.analysis import DependencyEdge, DependencyType
from typing import Dict
import os


async def build_dependency_graph(project: Project):
    """
    Build file dependency graph based on imports
    """
    print(f"üîó [DependencyAgent] Building dependency graph for project {project.id}")
    
    # Get all files with imports
    files = await FileMetadata.filter(project=project, imports__not_isnull=True).all()
    
    if not files:
        print(f"‚ö†Ô∏è  [DependencyAgent] No files with imports found")
        return 0
    
    # Create a mapping of module names to file objects
    file_map: Dict[str, FileMetadata] = {}
    for file in files:
        # Map by relative path without extension
        module_path = file.file_path.replace(os.sep, '.').replace('.py', '').replace('.js', '').replace('.ts', '')
        file_map[module_path] = file
        
        # Also map by just filename (without extension)
        file_name_no_ext = file.file_name.rsplit('.', 1)[0]
        file_map[file_name_no_ext] = file
    
    # Build edges
    edges_created = 0
    for source_file in files:
        if not source_file.imports:
            continue
        
        for import_statement in source_file.imports:
            # Try to find the target file
            import_parts = import_statement.split('.')
            target_file = None
            
            # Strategy 1: Full path match
            if import_statement in file_map:
                target_file = file_map[import_statement]
            
            # Strategy 2: Try last part (filename)
            elif import_parts[-1] in file_map:
                target_file = file_map[import_parts[-1]]
            
            # Strategy 3: Try matching relative paths
            else:
                for potential_path, file_obj in file_map.items():
                    if potential_path.endswith(import_parts[-1]):
                        target_file = file_obj
                        break
            
            # If we found a match and it's not self-reference, create the edge
            if target_file and target_file.id != source_file.id:
                # Check if edge already exists
                existing = await DependencyEdge.filter(
                    project=project,
                    source_file=source_file,
                    target_file=target_file,
                    dependency_type=DependencyType.IMPORTS
                ).first()
                
                if existing:
                    # Increment strength
                    existing.strength += 1
                    await existing.save()
                else:
                    # Create new edge
                    await DependencyEdge.create(
                        project=project,
                        source_file=source_file,
                        target_file=target_file,
                        dependency_type=DependencyType.IMPORTS,
                        strength=1,
                        details={"import": import_statement}
                    )
                    edges_created += 1
    
    print(f"‚úÖ [DependencyAgent] Created {edges_created} dependency edges")
    return edges_created
