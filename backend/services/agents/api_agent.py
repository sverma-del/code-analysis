# Code Generated by Sidekick is for learning and experimentation purposes only.
from models.projects import Project, FileMetadata
from models.analysis import APIEndpoint, AnalysisArtifact, ArtifactType, ArtifactStatus
from openai import AsyncOpenAI
import os
import ast
import re
import json

client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))


async def extract_api_endpoints(project: Project):
    """
    Extract detailed API endpoint information using AST parsing
    """
    print(f"üåê [APIAgent] Extracting API endpoints for project {project.id}")
    
    # Get files that contain API routes
    route_files = await FileMetadata.filter(
        project=project,
        contains_api_routes=True
    ).all()
    
    if not route_files:
        print(f"‚ö†Ô∏è  [APIAgent] No route files found")
        return 0
    
    endpoints_created = 0
    
    for file in route_files:
        # Read the file content
        extract_path = f"storage/extracted/{project.id}"
        full_path = os.path.join(extract_path, file.file_path)
        
        if not os.path.exists(full_path):
            continue
        
        try:
            with open(full_path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
        except Exception as e:
            print(f"Error reading {file.file_path}: {e}")
            continue
        
        # Extract endpoints based on language
        if file.extension == ".py":
            endpoints = extract_python_endpoints_ast(content, file)
        elif file.extension in [".js", ".ts", ".jsx", ".tsx"]:
            endpoints = extract_js_endpoints(content, file)
        else:
            continue
        
        # Store endpoints in database
        for endpoint in endpoints:
            await APIEndpoint.create(
                project=project,
                file_metadata=file,
                method=endpoint['method'],
                path=endpoint['path'],
                handler_function=endpoint.get('function'),
                requires_auth=endpoint.get('requires_auth', False),
                line_number=endpoint.get('line'),
                request_schema=endpoint.get('request_schema'),
                response_schema=endpoint.get('response_schema'),
                description=endpoint.get('description')
            )
            endpoints_created += 1
    
    print(f"‚úÖ [APIAgent] Created {endpoints_created} API endpoints")
    
    # Generate API catalog summary with LLM
    if endpoints_created > 0:
        await generate_api_catalog(project)
    
    return endpoints_created


def extract_python_endpoints_ast(content: str, file: FileMetadata):
    """
    Extract API endpoints from Python using AST parsing
    Supports: FastAPI, Flask, Django REST Framework
    """
    endpoints = []
    
    try:
        tree = ast.parse(content)
    except SyntaxError as e:
        print(f"Syntax error parsing {file.file_name}: {e}")
        return endpoints
    
    # Walk through all function definitions
    for node in ast.walk(tree):
        if not isinstance(node, ast.FunctionDef):
            continue
        
        # Check decorators for route definitions
        for decorator in node.decorator_list:
            endpoint_info = parse_decorator(decorator, node, content)
            if endpoint_info:
                endpoints.append(endpoint_info)
    
    return endpoints


def parse_decorator(decorator, func_node, content):
    """
    Parse a decorator to extract API endpoint information
    Handles FastAPI, Flask, Django patterns
    """
    endpoint = None
    
    # Handle decorator calls like @app.get("/path")
    if isinstance(decorator, ast.Call):
        if isinstance(decorator.func, ast.Attribute):
            # Pattern: app.get, router.post, etc.
            obj_name = get_full_name(decorator.func.value)
            method_name = decorator.func.attr
            
            # FastAPI/Flask HTTP methods
            http_methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head']
            
            if method_name.lower() in http_methods:
                # FastAPI: @router.get("/users")
                endpoint = {
                    'method': method_name.upper(),
                    'path': extract_path_from_decorator(decorator),
                    'function': func_node.name,
                    'line': func_node.lineno,
                    'requires_auth': check_requires_auth(func_node),
                    'description': ast.get_docstring(func_node),
                    'request_schema': extract_request_schema(func_node),
                    'response_schema': extract_response_schema(func_node)
                }
            
            elif method_name == 'route':
                # Flask: @app.route("/users", methods=["GET", "POST"])
                path = extract_path_from_decorator(decorator)
                methods = extract_methods_from_decorator(decorator)
                
                if not methods:
                    methods = ['GET']  # Default Flask method
                
                # Return first method (will create multiple entries if needed)
                endpoint = {
                    'method': methods[0],
                    'path': path,
                    'function': func_node.name,
                    'line': func_node.lineno,
                    'requires_auth': check_requires_auth(func_node),
                    'description': ast.get_docstring(func_node)
                }
        
        elif isinstance(decorator.func, ast.Name):
            # Pattern: @route, @api_view (Django REST)
            decorator_name = decorator.func.id
            
            if decorator_name == 'api_view':
                # Django REST: @api_view(['GET', 'POST'])
                methods = extract_methods_from_decorator(decorator)
                if methods:
                    endpoint = {
                        'method': methods[0],
                        'path': f"/{func_node.name}",  # Approximation
                        'function': func_node.name,
                        'line': func_node.lineno,
                        'requires_auth': check_requires_auth(func_node),
                        'description': ast.get_docstring(func_node)
                    }
    
    # Handle simple decorators like @route
    elif isinstance(decorator, ast.Attribute):
        method_name = decorator.attr
        http_methods = ['get', 'post', 'put', 'delete', 'patch']
        
        if method_name.lower() in http_methods:
            endpoint = {
                'method': method_name.upper(),
                'path': f"/{func_node.name}",  # Default path
                'function': func_node.name,
                'line': func_node.lineno,
                'requires_auth': check_requires_auth(func_node),
                'description': ast.get_docstring(func_node)
            }
    
    return endpoint


def extract_path_from_decorator(decorator):
    """
    Extract the path string from decorator arguments
    """
    if not decorator.args:
        return "/"
    
    # First argument is usually the path
    first_arg = decorator.args[0]
    
    if isinstance(first_arg, ast.Constant):
        return first_arg.value
    elif isinstance(first_arg, ast.Str):  # Python 3.7 compatibility
        return first_arg.s
    
    return "/"


def extract_methods_from_decorator(decorator):
    """
    Extract HTTP methods from decorator kwargs
    Example: methods=["GET", "POST"]
    """
    methods = []
    
    for keyword in decorator.keywords:
        if keyword.arg == 'methods':
            if isinstance(keyword.value, ast.List):
                for element in keyword.value.elts:
                    if isinstance(element, ast.Constant):
                        methods.append(element.value)
                    elif isinstance(element, ast.Str):
                        methods.append(element.s)
    
    return methods


def check_requires_auth(func_node):
    """
    Check if function requires authentication by analyzing decorators and parameters
    """
    # Check for auth-related decorators
    auth_decorators = [
        'login_required', 'authenticate', 'requires_auth',
        'permission_required', 'authorize'
    ]
    
    for decorator in func_node.decorator_list:
        decorator_name = None
        
        if isinstance(decorator, ast.Name):
            decorator_name = decorator.id
        elif isinstance(decorator, ast.Attribute):
            decorator_name = decorator.attr
        elif isinstance(decorator, ast.Call):
            if isinstance(decorator.func, ast.Name):
                decorator_name = decorator.func.id
            elif isinstance(decorator.func, ast.Attribute):
                decorator_name = decorator.func.attr
        
        if decorator_name and decorator_name.lower() in auth_decorators:
            return True
    
    # Check function parameters for Depends/current_user patterns
    for arg in func_node.args.args:
        arg_name = arg.arg.lower()
        
        # FastAPI Depends pattern
        if arg.annotation:
            annotation_str = ast.unparse(arg.annotation) if hasattr(ast, 'unparse') else str(arg.annotation)
            if 'depends' in annotation_str.lower() or 'current_user' in annotation_str.lower():
                return True
        
        # Common auth parameter names
        if arg_name in ['current_user', 'user', 'token', 'auth']:
            return True
    
    return False


def extract_request_schema(func_node):
    """
    Extract request schema from function parameters (Pydantic models)
    """
    schemas = []
    
    for arg in func_node.args.args:
        if arg.annotation:
            # Get the type annotation
            annotation_str = ast.unparse(arg.annotation) if hasattr(ast, 'unparse') else get_full_name(arg.annotation)
            
            # Check if it looks like a Pydantic model (capitalized, not a basic type)
            if annotation_str and annotation_str[0].isupper() and annotation_str not in ['str', 'int', 'bool', 'float', 'dict', 'list']:
                schemas.append({
                    'parameter': arg.arg,
                    'type': annotation_str
                })
    
    return schemas if schemas else None


def extract_response_schema(func_node):
    """
    Extract response schema from return type annotation
    """
    if func_node.returns:
        return_type = ast.unparse(func_node.returns) if hasattr(ast, 'unparse') else get_full_name(func_node.returns)
        return {'type': return_type}
    
    return None


def get_full_name(node):
    """
    Get the full name of a node (e.g., app.router.get -> 'router')
    """
    if isinstance(node, ast.Name):
        return node.id
    elif isinstance(node, ast.Attribute):
        return node.attr
    elif isinstance(node, ast.Constant):
        return str(node.value)
    return ""

def extract_js_endpoints(content: str, file: FileMetadata):
    """
    Improved extraction for JavaScript/TypeScript API endpoints.
    Supports Express, NestJS, Fastify, Koa, and Hapi.
    """
    endpoints = []
    seen_combinations = set()  # To prevent duplicates from overlapping regexes

    # 1. Standard Express/Koa/Fastify pattern: .method('/path', ...)
    # Now agnostic to the variable name (e.g., v1.get, server.post, auth.put)
    standard_pattern = r'\.(get|post|put|delete|patch|options|all|use)\s*\(\s*["\']([^"\']+)["\']'
    
    # 2. Express Route Chaining: .route('/path').get(handler)
    chain_pattern = r'\.route\s*\(\s*["\']([^"\']+)["\']\s*\)\s*\.(get|post|put|delete|patch)'

    # 3. Object-based definitions (Hapi.js or Fastify routes)
    # path: '/users', method: 'GET'
    object_pattern = r'path\s*:\s*["\']([^"\']+)["\']\s*,\s*method\s*:\s*["\']([^"\']+)["\']'

    # Process Standard & Chain patterns
    for pattern_type, pattern in [("std", standard_pattern), ("chain", chain_pattern)]:
        for match in re.finditer(pattern, content, re.IGNORECASE):
            # For standard, g1=method, g2=path. For chain, g1=path, g2=method.
            if pattern_type == "std":
                method, path = match.group(1).upper(), match.group(2)
            else:
                path, method = match.group(1), match.group(2).upper()

            # Skip common false positives (like app.use(express.json()))
            if path.endswith('.json') or path.endswith('.js') or method == "USE" and "/" not in path:
                continue

            combo = f"{method}:{path}"
            if combo not in seen_combinations:
                line_number = content[:match.start()].count('\n') + 1
                endpoints.append({
                    'method': method,
                    'path': path,
                    'function': None, # Difficult to extract without AST for JS
                    'line': line_number,
                    'requires_auth': check_js_auth(content, match.start(), match.end())
                })
                seen_combinations.add(combo)

    # 4. NestJS / TypeScript Decorators: @Get('/path')
    # Improved to handle @Get() (no path provided, uses function name)
    nestjs_pattern = r'@(Get|Post|Put|Delete|Patch|Options|All)\s*\(\s*(?:["\']([^"\']+)["\'])?\s*\)\s*(?:async\s+)?(\w+)\s*\('
    for match in re.finditer(nestjs_pattern, content):
        method = match.group(1).upper()
        path = match.group(2) if match.group(2) else f"/{match.group(3)}"
        function_name = match.group(3)
        
        combo = f"{method}:{path}"
        if combo not in seen_combinations:
            line_number = content[:match.start()].count('\n') + 1
            endpoints.append({
                'method': method,
                'path': path,
                'function': function_name,
                'line': line_number,
                'requires_auth': check_js_auth(content, match.start(), match.end())
            })
            seen_combinations.add(combo)

    # 5. Hapi/Object Pattern
    for match in re.finditer(object_pattern, content, re.IGNORECASE):
        path, method = match.group(1), match.group(2).upper()
        combo = f"{method}:{path}"
        if combo not in seen_combinations:
            line_number = content[:match.start()].count('\n') + 1
            endpoints.append({
                'method': method,
                'path': path,
                'function': None,
                'line': line_number,
                'requires_auth': check_js_auth(content, match.start(), match.end())
            })
            seen_combinations.add(combo)

    return endpoints


def check_js_auth(content: str, start: int, end: int):
    """
    Improved JS auth detection.
    Looks for auth keywords and common middleware names in the route definition.
    """
    # Look at the specific line and the 2 lines above it
    prefix = content[max(0, start-200):start].lower()
    # Look at the arguments passed to the route (where middleware usually sits)
    suffix = content[end:min(len(content), end+200)].lower()
    
    context = prefix + " " + suffix
    
    auth_indicators = [
        'auth', 'jwt', 'passport', 'guard', 'protected', 
        'session', 'isauthenticated', 'isauth', 'verifytoken',
        'requireuser', 'restrictto', 'acl', 'authorize'
    ]
    
    return any(indicator in context for indicator in auth_indicators)

async def generate_api_catalog(project: Project):
    """
    Generate a comprehensive API catalog using LLM
    """
    # Get all endpoints
    endpoints = await APIEndpoint.filter(project=project).prefetch_related('file_metadata').all()
    
    if not endpoints:
        return
    
    # Group by file
    endpoints_by_file = {}
    for ep in endpoints:
        file_path = ep.file_metadata.file_path
        if file_path not in endpoints_by_file:
            endpoints_by_file[file_path] = []
        endpoints_by_file[file_path].append({
            'method': ep.method,
            'path': ep.path,
            'function': ep.handler_function,
            'requires_auth': ep.requires_auth,
            'description': ep.description
        })
    
    # Format endpoints for prompt
    endpoint_list = []
    for file_path, eps in endpoints_by_file.items():
        endpoint_list.append(f"\n{file_path}:")
        for ep in eps:
            auth_marker = " [Auth]" if ep['requires_auth'] else ""
            desc = f" - {ep['description'][:50]}..." if ep.get('description') else ""
            endpoint_list.append(f"  {ep['method']} {ep['path']}{auth_marker}{desc}")
    
    prompt = f"""Analyze this API and create a comprehensive catalog.

Project: {project.name}
Framework: {project.detected_framework}
Language: {project.detected_language}

Endpoints found:
{''.join(endpoint_list)}

Generate a JSON response with:
{{
  "summary": "Brief overview of the API purpose",
  "endpoint_groups": [
    {{
      "name": "Authentication",
      "endpoints": ["POST /auth/login", "POST /auth/register"],
      "description": "User authentication endpoints"
    }}
  ],
  "authentication_method": "Description of auth mechanism used",
  "common_patterns": ["REST", "CRUD operations", "etc"]
}}

Respond ONLY with valid JSON, no markdown formatting."""
    
    try:
        response = await client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3,
            max_tokens=1500
        )
        
        catalog_content = response.choices[0].message.content.strip()
        
        # Clean up markdown if present
        if "```json" in catalog_content:
            catalog_content = catalog_content.split("```json")[1].split("```")[0].strip()
        elif "```" in catalog_content:
            catalog_content = catalog_content.split("```")[1].split("```")[0].strip()
        
        catalog_data = json.loads(catalog_content)
        
        # Store in AnalysisArtifact
        await AnalysisArtifact.create(
            project=project,
            artifact_type=ArtifactType.API_CATALOG,
            content=catalog_data,
            status=ArtifactStatus.COMPLETED
        )
        
        print(f"‚úÖ [APIAgent] Generated API catalog with LLM")
        
    except Exception as e:
        print(f"‚ùå [APIAgent] Error generating catalog: {e}")
        await AnalysisArtifact.create(
            project=project,
            artifact_type=ArtifactType.API_CATALOG,
            content={"endpoints_count": len(endpoints), "error": "Failed to generate summary"},
            status=ArtifactStatus.FAILED,
            error_message=str(e)
        )
