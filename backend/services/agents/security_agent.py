# Code Generated by Sidekick is for learning and experimentation purposes only.
from models.projects import Project, FileMetadata
from models.analysis import SecurityFinding, AnalysisArtifact, ArtifactType, ArtifactStatus
from openai import AsyncOpenAI
import os
import re
import json

client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))


async def analyze_security(project: Project):
    """
    Analyze security patterns and authentication flow
    """
    print(f"üîí [SecurityAgent] Analyzing security for project {project.id}")
    
    # Get auth-related files
    auth_files = await FileMetadata.filter(
        project=project,
        contains_auth=True
    ).all()
    
    if not auth_files:
        print("‚ö†Ô∏è  [SecurityAgent] No auth-related files found")
        return 0
    
    findings = []
    extract_path = f"storage/extracted/{project.id}"
    
    for file in auth_files:
        full_path = os.path.join(extract_path, file.file_path)
        
        if not os.path.exists(full_path):
            continue
        
        with open(full_path, "r", encoding="utf-8", errors="ignore") as f:
            content = f.read()
        
        # Detect security patterns
        file_findings = detect_security_patterns(content, file.file_path)
        findings.extend(file_findings)
    
    # Store findings in database
    for finding in findings:
        await SecurityFinding.create(
            project=project,
            finding_type=finding['type'],
            file_paths=finding['files'],
            code_snippets=finding.get('snippets', []),
            description=finding.get('description'),
            severity='info'
        )
    
    print(f"‚úÖ [SecurityAgent] Found {len(findings)} security patterns")
    
    # Generate security documentation
    await generate_security_documentation(project, findings, auth_files)
    
    return len(findings)


def detect_security_patterns(content: str, filepath: str):
    """
    Detect common security patterns in code
    """
    findings = []
    content_lower = content.lower()
    
    # Pattern 1: Password Hashing
    hashing_patterns = [
        r'bcrypt\.(hashpw|gensalt|checkpw)',
        r'argon2\.',
        r'pbkdf2_',
        r'scrypt\.',
        r'from passlib import',
    ]
    
    for pattern in hashing_patterns:
        if re.search(pattern, content, re.IGNORECASE):
            # Extract code snippet
            matches = re.finditer(pattern, content, re.IGNORECASE)
            snippets = []
            for match in matches:
                start = max(0, match.start() - 100)
                end = min(len(content), match.end() + 100)
                snippets.append(content[start:end])
            
            findings.append({
                'type': 'password_hashing',
                'files': [filepath],
                'snippets': snippets[:2],  # Limit to 2 snippets
                'description': f'Password hashing implementation found using {pattern}'
            })
            break
    
    # Pattern 2: JWT Usage
    jwt_patterns = [
        r'jwt\.encode',
        r'jwt\.decode',
        r'create_access_token',
        r'verify_token',
        r'from jose import jwt',
    ]
    
    for pattern in jwt_patterns:
        if re.search(pattern, content, re.IGNORECASE):
            matches = re.finditer(pattern, content, re.IGNORECASE)
            snippets = []
            for match in matches:
                start = max(0, match.start() - 100)
                end = min(len(content), match.end() + 100)
                snippets.append(content[start:end])
            
            findings.append({
                'type': 'jwt_usage',
                'files': [filepath],
                'snippets': snippets[:2],
                'description': 'JWT token handling found'
            })
            break
    
    # Pattern 3: Authentication Middleware
    auth_middleware_patterns = [
        r'def\s+(?:get_current_user|authenticate|verify_token)',
        r'@(?:require_auth|login_required|authenticate)',
        r'async\s+def\s+(?:get_current_user|authenticate)',
    ]
    
    for pattern in auth_middleware_patterns:
        if re.search(pattern, content):
            findings.append({
                'type': 'authentication_flow',
                'files': [filepath],
                'snippets': [],
                'description': 'Authentication middleware detected'
            })
            break
    
    # Pattern 4: CORS Configuration
    if 'cors' in content_lower or 'cross-origin' in content_lower:
        findings.append({
            'type': 'cors_config',
            'files': [filepath],
            'snippets': [],
            'description': 'CORS configuration found'
        })
    
    # Pattern 5: Input Validation
    validation_patterns = [
        r'from pydantic import',
        r'@validator',
        r'BaseModel',
        r'Joi\.',
        r'express-validator',
    ]
    
    for pattern in validation_patterns:
        if re.search(pattern, content):
            findings.append({
                'type': 'input_validation',
                'files': [filepath],
                'snippets': [],
                'description': 'Input validation framework detected'
            })
            break
    
    return findings


async def generate_security_documentation(project: Project, findings: list, auth_files: list):
    """
    Generate comprehensive security documentation using LLM
    """
    # Group findings by type
    findings_by_type = {}
    for finding in findings:
        f_type = finding['type']
        if f_type not in findings_by_type:
            findings_by_type[f_type] = []
        findings_by_type[f_type].append(finding)
    
    # Format for prompt
    findings_text = []
    for f_type, type_findings in findings_by_type.items():
        files = list(set([f for finding in type_findings for f in finding['files']]))
        findings_text.append(f"- {f_type}: Found in {len(files)} files")
    
    prompt = f"""Analyze the security implementation of this project and generate comprehensive documentation.

Project: {project.name}
Framework: {project.detected_framework}

Security Patterns Found:
{chr(10).join(findings_text)}

Auth-related files:
{chr(10).join([f.file_path for f in auth_files[:10]])}

Generate a JSON response with:
{{
  "authentication_overview": "How authentication works in this project",
  "authentication_flow": {{
    "registration": "Step-by-step registration process",
    "login": "Step-by-step login process",
    "token_validation": "How tokens are validated"
  }},
  "security_features": [
    {{
      "feature": "Password Hashing",
      "implementation": "bcrypt with salt",
      "files": ["core/security.py"]
    }}
  ],
  "best_practices_observed": ["List of good practices"],
  "recommendations": ["Security recommendations if any"]
}}

Only respond with valid JSON."""
    
    try:
        response = await client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3
        )
        
        security_content = response.choices[0].message.content
        
        # Parse JSON
        if "```json" in security_content:
            security_content = security_content.split("```json")[1].split("```")[0].strip()
        elif "```" in security_content:
            security_content = security_content.split("```")[1].split("```")[0].strip()
        
        security_data = json.loads(security_content)
        
        # Store in AnalysisArtifact
        await AnalysisArtifact.create(
            project=project,
            artifact_type=ArtifactType.SECURITY_ANALYSIS,
            content=security_data,
            status=ArtifactStatus.COMPLETED
        )
        
        print(f"‚úÖ [SecurityAgent] Generated security documentation")
        
    except Exception as e:
        print(f"‚ùå [SecurityAgent] Error generating documentation: {e}")
        await AnalysisArtifact.create(
            project=project,
            artifact_type=ArtifactType.SECURITY_ANALYSIS,
            content={"error": str(e)},
            status=ArtifactStatus.FAILED,
            error_message=str(e)
        )
