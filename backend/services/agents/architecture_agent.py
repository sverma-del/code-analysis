# Code Generated by Sidekick is for learning and experimentation purposes only.
from models.projects import Project, FileMetadata
from models.analysis import ComponentMetadata, ComponentType, AnalysisArtifact, ArtifactType, ArtifactStatus
from openai import AsyncOpenAI
import os
import json

client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))


async def analyze_architecture(project: Project):
    """
    Analyze project architecture and identify components
    """
    print(f"üèóÔ∏è  [ArchitectureAgent] Analyzing architecture for project {project.id}")
    
    # Get all files
    files = await FileMetadata.filter(project=project).all()
    
    if not files:
        print(f"‚ö†Ô∏è  [ArchitectureAgent] No files found")
        return 0
    
    # Identify components by directory structure and naming conventions
    components = identify_components_by_structure(files)
    
    # Store components in database
    for comp in components:
        await ComponentMetadata.create(
            project=project,
            component_name=comp['name'],
            component_type=comp['type'],
            file_paths=comp['files'],
            responsibilities=comp.get('description')
        )
    
    print(f"‚úÖ [ArchitectureAgent] Identified {len(components)} components")
    
    # Generate architecture overview with LLM
    await generate_architecture_overview(project, components, files)
    
    return len(components)


def identify_components_by_structure(files: list) -> list:
    """
    Identify architectural components based on file organization
    """
    components = []
    
    # Group files by top-level directory
    directory_groups = {}
    for file in files:
        parts = file.file_path.split(os.sep)
        if len(parts) > 1:
            directory = parts[0]
            if directory not in directory_groups:
                directory_groups[directory] = []
            directory_groups[directory].append(file.file_path)
    
    # Map common directory names to component types
    component_type_map = {
        'api': ComponentType.CONTROLLER,
        'routes': ComponentType.CONTROLLER,
        'controllers': ComponentType.CONTROLLER,
        'handlers': ComponentType.CONTROLLER,
        'services': ComponentType.SERVICE,
        'models': ComponentType.MODEL,
        'schemas': ComponentType.MODEL,
        'entities': ComponentType.MODEL,
        'utils': ComponentType.UTILITY,
        'helpers': ComponentType.HELPER,
        'lib': ComponentType.UTILITY,
        'middleware': ComponentType.MIDDLEWARE,
        'middlewares': ComponentType.MIDDLEWARE,
        'config': ComponentType.UTILITY,
        'core': ComponentType.SERVICE,
        'repositories': ComponentType.REPOSITORY,
        'repository': ComponentType.REPOSITORY,
    }
    
    # Create components from directory structure
    for directory, file_paths in directory_groups.items():
        if len(file_paths) < 1:  # Skip empty directories
            continue
            
        # Determine component type
        comp_type = component_type_map.get(directory.lower(), ComponentType.UTILITY)
        
        components.append({
            'name': directory.capitalize(),
            'type': comp_type,
            'files': file_paths,
            'description': f"{directory.capitalize()} component with {len(file_paths)} files"
        })
    
    # Also create special components based on file characteristics
    route_files = [f for f in files if f.contains_api_routes]
    if route_files and len(route_files) > 0:
        components.append({
            'name': 'API Layer',
            'type': ComponentType.CONTROLLER,
            'files': [f.file_path for f in route_files],
            'description': 'HTTP API endpoint handlers and routes'
        })
    
    model_files = [f for f in files if f.contains_db_models]
    if model_files and len(model_files) > 0:
        components.append({
            'name': 'Data Layer',
            'type': ComponentType.MODEL,
            'files': [f.file_path for f in model_files],
            'description': 'Database models and data schemas'
        })
    
    auth_files = [f for f in files if f.contains_auth]
    if auth_files and len(auth_files) > 0:
        components.append({
            'name': 'Authentication',
            'type': ComponentType.MIDDLEWARE,
            'files': [f.file_path for f in auth_files],
            'description': 'Authentication and authorization logic'
        })
    
    return components


async def generate_architecture_overview(project: Project, components: list, files: list):
    """
    Generate architecture documentation using LLM
    """
    # Prepare component summary
    component_summary = []
    for c in components:
        component_summary.append(f"- {c['name']} ({c['type'].value}): {len(c['files'])} files")
    
    # Get some file examples
    file_examples = [f.file_path for f in files[:20]]  # First 20 files
    
    prompt = f"""Analyze this software project architecture and provide insights.

Project Name: {project.name}
Language: {project.detected_language}
Framework: {project.detected_framework}
Total Files: {project.file_count}
API Endpoints: {project.endpoint_count}

Components identified:
{chr(10).join(component_summary)}

Sample file structure:
{chr(10).join(file_examples)}

Generate a JSON response with:
{{
  "architecture_pattern": "Name of pattern (e.g., MVC, Layered, Microservices, Modular Monolith)",
  "overview": "2-3 sentences describing the architecture",
  "layers": [
    {{
      "name": "Presentation Layer",
      "components": ["API", "Routes"],
      "responsibility": "Handles HTTP requests and responses"
    }}
  ],
  "key_observations": ["Notable patterns or practices observed"],
  "technology_stack": ["Key technologies and frameworks used"],
  "strengths": ["Architectural strengths"],
  "improvement_suggestions": ["Potential improvements"]
}}

Respond ONLY with valid JSON, no markdown."""
    
    try:
        response = await client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.3,
            max_tokens=2000
        )
        
        arch_content = response.choices[0].message.content.strip()
        
        # Clean up markdown if present
        if "```json" in arch_content:
            arch_content = arch_content.split("```json")[1].split("```")[0].strip()
        elif "```" in arch_content:
            arch_content = arch_content.split("```")[1].split("```")[0].strip()
        
        arch_data = json.loads(arch_content)
        
        # Store in AnalysisArtifact
        await AnalysisArtifact.create(
            project=project,
            artifact_type=ArtifactType.ARCHITECTURE_MAP,
            content=arch_data,
            status=ArtifactStatus.COMPLETED
        )
        
        print(f"‚úÖ [ArchitectureAgent] Generated architecture overview")
        
    except Exception as e:
        print(f"‚ùå [ArchitectureAgent] Error generating overview: {e}")
        await AnalysisArtifact.create(
            project=project,
            artifact_type=ArtifactType.ARCHITECTURE_MAP,
            content={"component_count": len(components), "error": "Failed to generate overview"},
            status=ArtifactStatus.FAILED,
            error_message=str(e)
        )
