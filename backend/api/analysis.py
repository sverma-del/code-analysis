# Code Generated by Sidekick is for learning and experimentation purposes only.
from fastapi import APIRouter, Depends, HTTPException
from models.users import User
from models.projects import Project, FileMetadata
from models.analysis import (
    AnalysisArtifact, 
    ArtifactType,
    ArtifactStatus,
    ComponentMetadata, 
    DependencyEdge,
    APIEndpoint,
    SecurityFinding,
    DatabaseModel
)
from api.auth import get_current_user

router = APIRouter()


@router.get("/projects/{project_id}/architecture")
async def get_architecture(project_id: str, current_user: User = Depends(get_current_user)):
    """
    Get architecture analysis for a project
    """
    # Verify project ownership
    project = await Project.get_or_none(id=project_id, user=current_user)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Get architecture artifact (generated by LLM)
    artifact = await AnalysisArtifact.get_or_none(
        project=project,
        artifact_type=ArtifactType.ARCHITECTURE_MAP
    )
    
    # Get components
    components = await ComponentMetadata.filter(project=project).all()
    
    # Get dependency statistics
    dep_count = await DependencyEdge.filter(project=project).count()
    
    return {
        "project_name": project.name,
        "framework": project.detected_framework,
        "language": project.detected_language,
        "architecture_overview": artifact.content if artifact else None,
        "artifact_status": artifact.status if artifact else None,
        "components": [
            {
                "name": c.component_name,
                "type": c.component_type,
                "file_count": len(c.file_paths),
                "files": c.file_paths[:5],  # Show first 5 files
                "responsibilities": c.responsibilities,
                "technologies": c.technologies
            }
            for c in components
        ],
        "total_dependencies": dep_count,
        "total_components": len(components)
    }


@router.get("/projects/{project_id}/api-catalog")
async def get_api_catalog(project_id: str, current_user: User = Depends(get_current_user)):
    """
    Get API documentation and catalog
    """
    project = await Project.get_or_none(id=project_id, user=current_user)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Get API catalog artifact (generated by LLM)
    artifact = await AnalysisArtifact.get_or_none(
        project=project,
        artifact_type=ArtifactType.API_CATALOG
    )
    
    # Get all endpoints
    endpoints = await APIEndpoint.filter(project=project).prefetch_related('file_metadata').all()
    
    # Group endpoints by method
    endpoints_by_method = {}
    for ep in endpoints:
        if ep.method not in endpoints_by_method:
            endpoints_by_method[ep.method] = []
        endpoints_by_method[ep.method].append({
            "path": ep.path,
            "handler": ep.handler_function,
            "requires_auth": ep.requires_auth,
            "file": ep.file_metadata.file_path,
            "line": ep.line_number,
            "description": ep.description
        })
    
    # Group endpoints by file
    endpoints_by_file = {}
    for ep in endpoints:
        file_path = ep.file_metadata.file_path
        if file_path not in endpoints_by_file:
            endpoints_by_file[file_path] = []
        endpoints_by_file[file_path].append({
            "method": ep.method,
            "path": ep.path,
            "handler": ep.handler_function,
            "requires_auth": ep.requires_auth,
            "line": ep.line_number
        })
    
    return {
        "project_name": project.name,
        "framework": project.detected_framework,
        "catalog": artifact.content if artifact else None,
        "total_endpoints": len(endpoints),
        "endpoints_by_method": endpoints_by_method,
        "endpoints_by_file": endpoints_by_file,
        "all_endpoints": [
            {
                "method": ep.method,
                "path": ep.path,
                "handler": ep.handler_function,
                "requires_auth": ep.requires_auth,
                "file": ep.file_metadata.file_path,
                "line": ep.line_number,
                "description": ep.description
            }
            for ep in endpoints
        ]
    }


@router.get("/projects/{project_id}/dependencies")
async def get_dependencies(project_id: str, current_user: User = Depends(get_current_user)):
    """
    Get dependency graph data
    """
    project = await Project.get_or_none(id=project_id, user=current_user)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Get all dependencies
    dependencies = await DependencyEdge.filter(project=project).prefetch_related(
        'source_file', 'target_file'
    ).all()
    
    # Format for graph visualization (nodes and edges)
    nodes_dict = {}
    edges = []
    
    for dep in dependencies:
        # Add source node
        source_name = dep.source_file.file_name
        if source_name not in nodes_dict:
            nodes_dict[source_name] = {
                "id": source_name,
                "label": source_name,
                "path": dep.source_file.file_path,
                "extension": dep.source_file.extension,
                "outgoing": 0,
                "incoming": 0
            }
        nodes_dict[source_name]["outgoing"] += 1
        
        # Add target node
        target_name = dep.target_file.file_name
        if target_name not in nodes_dict:
            nodes_dict[target_name] = {
                "id": target_name,
                "label": target_name,
                "path": dep.target_file.file_path,
                "extension": dep.target_file.extension,
                "outgoing": 0,
                "incoming": 0
            }
        nodes_dict[target_name]["incoming"] += 1
        
        edges.append({
            "source": source_name,
            "target": target_name,
            "type": dep.dependency_type,
            "strength": dep.strength
        })
    
    # Calculate circular dependencies
    circular_deps = []
    for edge in edges:
        reverse_exists = any(
            e["source"] == edge["target"] and e["target"] == edge["source"]
            for e in edges
        )
        if reverse_exists and edge["source"] < edge["target"]:  # Avoid duplicates
            circular_deps.append({
                "file1": edge["source"],
                "file2": edge["target"]
            })
    
    return {
        "project_name": project.name,
        "nodes": list(nodes_dict.values()),
        "edges": edges,
        "statistics": {
            "total_dependencies": len(edges),
            "total_files": len(nodes_dict),
            "circular_dependencies": len(circular_deps),
            "most_dependent": sorted(
                nodes_dict.values(),
                key=lambda x: x["outgoing"],
                reverse=True
            )[:5],
            "most_depended_on": sorted(
                nodes_dict.values(),
                key=lambda x: x["incoming"],
                reverse=True
            )[:5]
        },
        "circular_dependencies": circular_deps
    }


@router.get("/projects/{project_id}/database-schema")
async def get_database_schema(project_id: str, current_user: User = Depends(get_current_user)):
    """
    Get database schema analysis
    """
    project = await Project.get_or_none(id=project_id, user=current_user)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Get database schema artifact
    artifact = await AnalysisArtifact.get_or_none(
        project=project,
        artifact_type=ArtifactType.DATABASE_SCHEMA
    )
    
    # Import DatabaseModel here to avoid circular imports
    from models.analysis import DatabaseModel
    
    # Get database models
    models = await DatabaseModel.filter(project=project).prefetch_related('file_metadata').all()
    
    # Organize models by file
    models_by_file = {}
    for model in models:
        file_path = model.file_metadata.file_path if model.file_metadata else "Unknown"
        if file_path not in models_by_file:
            models_by_file[file_path] = []
        models_by_file[file_path].append({
            "name": model.model_name,
            "table_name": model.table_name,
            "fields": model.db_fields,  # ✅ Updated to db_fields
            "relationships": model.relationships,
            "indexes": model.indexes
        })
    
    return {
        "project_name": project.name,
        "framework": project.detected_framework,
        "schema_overview": artifact.content if artifact else None,
        "artifact_status": artifact.status if artifact else None,
        "total_models": len(models),
        "models": [
            {
                "name": m.model_name,
                "table_name": m.table_name,
                "field_count": len(m.db_fields) if m.db_fields else 0,  # ✅ Updated
                "fields": m.db_fields,  # ✅ Updated
                "relationships": m.relationships,
                "indexes": m.indexes,
                "validators": m.validators,
                "description": m.description,
                "file": m.file_metadata.file_path if m.file_metadata else None
            }
            for m in models
        ],
        "models_by_file": models_by_file
    }

@router.get("/projects/{project_id}/security")
async def get_security(project_id: str, current_user: User = Depends(get_current_user)):
    """
    Get security analysis
    """
    project = await Project.get_or_none(id=project_id, user=current_user)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Get security artifact
    artifact = await AnalysisArtifact.get_or_none(
        project=project,
        artifact_type=ArtifactType.SECURITY_ANALYSIS
    )
    
    # Get security findings
    findings = await SecurityFinding.filter(project=project).all()
    
    # Group findings by severity
    findings_by_severity = {
        "critical": [],
        "high": [],
        "medium": [],
        "low": [],
        "info": []
    }
    
    for finding in findings:
        severity = finding.severity.lower()
        findings_by_severity[severity].append({
            "type": finding.finding_type,
            "description": finding.description,
            "file_paths": finding.file_paths,
            "recommendation": finding.recommendation,
            "cwe_id": finding.cwe_id,
            "owasp_category": finding.owasp_category
        })
    
    # Calculate risk score
    severity_weights = {"critical": 10, "high": 7, "medium": 4, "low": 2, "info": 0}
    risk_score = sum(
        severity_weights.get(severity, 0) * len(items)
        for severity, items in findings_by_severity.items()
    )
    
    return {
        "project_name": project.name,
        "analysis_overview": artifact.content if artifact else None,
        "artifact_status": artifact.status if artifact else None,
        "total_findings": len(findings),
        "risk_score": risk_score,
        "findings_by_severity": findings_by_severity,
        "severity_counts": {
            severity: len(items)
            for severity, items in findings_by_severity.items()
        },
        "all_findings": [
            {
                "type": f.finding_type,
                "description": f.description,
                "severity": f.severity,
                "files": f.file_paths,
                "recommendation": f.recommendation,
                "cwe_id": f.cwe_id,
                "owasp_category": f.owasp_category
            }
            for f in findings
        ]
    }

@router.get("/projects/{project_id}/setup-guide")
async def get_setup_guide(project_id: str, current_user: User = Depends(get_current_user)):
    """
    Get setup and installation instructions
    """
    project = await Project.get_or_none(id=project_id, user=current_user)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Get setup instructions artifact
    artifact = await AnalysisArtifact.get_or_none(
        project=project,
        artifact_type=ArtifactType.SETUP_INSTRUCTIONS
    )
    
    # Get config files by common config file extensions/names
    config_extensions = ['.json', '.yaml', '.yml', '.toml', '.env', '.ini', '.config']
    config_names = [
        'package.json', 'requirements.txt', 'Gemfile', 'go.mod', 
        'composer.json', 'pom.xml', 'build.gradle', 'Cargo.toml',
        '.env', '.env.example', 'config.json', 'appsettings.json'
    ]
    
    all_files = await FileMetadata.filter(project=project).all()
    
    # Filter config files manually
    config_files = [
        f for f in all_files 
        if f.extension in config_extensions or f.file_name in config_names
    ]
    
    # Get entry points
    entry_points = await FileMetadata.filter(
        project=project,
        is_entry_point=True
    ).all()
    
    return {
        "project_name": project.name,
        "framework": project.detected_framework,
        "language": project.detected_language,
        "guide": artifact.content if artifact else None,
        "artifact_status": artifact.status if artifact else None,
        "config_files": [
            {
                "name": f.file_name,
                "path": f.file_path,
                "type": f.extension
            }
            for f in config_files
        ],
        "entry_points": [
            {
                "name": f.file_name,
                "path": f.file_path
            }
            for f in entry_points
        ]
    }

@router.get("/projects/{project_id}/analysis-summary")
async def get_analysis_summary(project_id: str, current_user: User = Depends(get_current_user)):
    """Get comprehensive summary of all analysis results"""
    project = await Project.get_or_none(id=project_id, user=current_user)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Get counts
    component_count = await ComponentMetadata.filter(project=project).count()
    endpoint_count = await APIEndpoint.filter(project=project).count()
    dependency_count = await DependencyEdge.filter(project=project).count()
    security_finding_count = await SecurityFinding.filter(project=project).count()
    
    # ✅ Add database model count
    try:
        from models.analysis import DatabaseModel
        database_model_count = await DatabaseModel.filter(project=project).count()
    except ImportError:
        database_model_count = 0
    
    # Get artifacts
    artifacts = await AnalysisArtifact.filter(project=project).all()
    
    artifact_status = {}
    for artifact in artifacts:
        artifact_status[artifact.artifact_type] = {
            "status": artifact.status,
            "created_at": artifact.created_at.isoformat(),
            "has_content": artifact.content is not None
        }
    
    # File type breakdown
    all_files = await FileMetadata.filter(project=project).all()
    file_types = {}
    for file in all_files:
        ext = file.extension or "no_extension"
        file_types[ext] = file_types.get(ext, 0) + 1
    
    # Security summary
    security_findings = await SecurityFinding.filter(project=project).all()
    severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
    for finding in security_findings:
        severity = (finding.severity or "info").lower()
        if severity in severity_counts:
            severity_counts[severity] += 1
    
    return {
        "project_name": project.name,
        "status": project.status,
        "framework": project.detected_framework,
        "language": project.detected_language,
        "created_at": project.created_at.isoformat(),
        "statistics": {
            "total_files": project.file_count,
            "file_types": file_types,
            "components_identified": component_count,
            "api_endpoints": endpoint_count,
            "dependencies": dependency_count,
            "database_models": database_model_count,  # ✅ Added
            "security_findings": security_finding_count
        },
        "security_summary": {
            "total_findings": security_finding_count,
            "by_severity": severity_counts
        },
        "artifacts": artifact_status,
        "completion_percentage": calculate_completion_percentage(artifacts),
        "analysis_sections": {
            "architecture": component_count > 0 or ArtifactType.ARCHITECTURE_MAP in artifact_status,
            "api_catalog": endpoint_count > 0 or ArtifactType.API_CATALOG in artifact_status,
            "dependencies": dependency_count > 0,
            "database": database_model_count > 0 or ArtifactType.DATABASE_SCHEMA in artifact_status,  # ✅ Updated
            "security": security_finding_count > 0 or ArtifactType.SECURITY_ANALYSIS in artifact_status,
            "setup": ArtifactType.SETUP_INSTRUCTIONS in artifact_status
        }
    }

def calculate_completion_percentage(artifacts: list) -> int:
    """
    Calculate what percentage of analysis is complete
    """
    expected_artifacts = [
        ArtifactType.ARCHITECTURE_MAP,
        ArtifactType.API_CATALOG,
        ArtifactType.DATABASE_SCHEMA,
        ArtifactType.SECURITY_ANALYSIS,
        ArtifactType.SETUP_INSTRUCTIONS
    ]
    
    completed = sum(
        1 for artifact in artifacts
        if artifact.artifact_type in expected_artifacts
        and artifact.status == ArtifactStatus.COMPLETED
    )
    
    return int((completed / len(expected_artifacts)) * 100)


@router.get("/projects/{project_id}/files")
async def get_project_files(
    project_id: str,
    contains_api: bool = None,
    contains_db: bool = None,
    extension: str = None,
    current_user: User = Depends(get_current_user)
):
    """
    Get filtered list of project files
    """
    project = await Project.get_or_none(id=project_id, user=current_user)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Build filter (only use fields that exist)
    filters = {"project": project}
    if contains_api is not None:
        filters["contains_api_routes"] = contains_api
    if contains_db is not None:
        filters["contains_db_models"] = contains_db
    if extension:
        filters["extension"] = extension
    
    files = await FileMetadata.filter(**filters).all()
    
    # Determine if file is likely a config file
    config_extensions = ['.json', '.yaml', '.yml', '.toml', '.env', '.ini', '.config', '.xml', '.gradle','.gemspec']
    config_names = [
        'package.json', 'requirements.txt', 'Gemfile', 'go.mod', 
        'composer.json', 'pom.xml', 'build.gradle', 'Cargo.toml'
    ]
    
    return {
        "project_name": project.name,
        "total_files": len(files),
        "files": [
            {
                "name": f.file_name,
                "path": f.file_path,
                "extension": f.extension,
                "size": f.size,
                "contains_api_routes": f.contains_api_routes,
                "contains_db_models": f.contains_db_models,
                "contains_auth": f.contains_auth,
                "is_entry_point": f.is_entry_point,
                "is_config_file": f.extension in config_extensions or f.file_name in config_names,  # Computed
                "imports": f.imports[:10] if f.imports else []
            }
            for f in files
        ]
    }