# Code Generated by Sidekick is for learning and experimentation purposes only.
# api/progress.py
import json
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, HTTPException
from models.users import User
from models.projects import Project
from models.progress import ProgressEvent
from services.progress_manager import get_progress_manager
from api.auth import get_current_user, get_current_user_ws
from typing import List

router = APIRouter()


@router.websocket("/ws/{project_id}")
async def websocket_progress(
    websocket: WebSocket, 
    project_id: str
):
    """
    WebSocket endpoint for real-time progress updates with Authentication
    """
    # 1. Extract Token from Header or Query Param
    # Note: Client-side 'websockets' lib can send headers, browsers usually use query params
    auth_header = websocket.headers.get("authorization")
    token = None
    
    if auth_header and auth_header.startswith("Bearer "):
        token = auth_header.split(" ")[1]
    else:
        token = websocket.query_params.get("token")

    # 2. Pre-Acceptance Validation
    # We must Accept the connection before we can send JSON error messages
    if not token:
        await websocket.accept()
        await websocket.send_json({"type": "error", "message": "Missing authentication token"})
        await websocket.close(code=1008)
        return

    user = await get_current_user_ws(token)
    if not user:
        await websocket.accept()
        await websocket.send_json({"type": "error", "message": "Invalid or expired token"})
        await websocket.close(code=1008)
        return

    project = await Project.get_or_none(id=project_id, user=user)
    if not project:
        await websocket.accept()
        await websocket.send_json({"type": "error", "message": "Project not found or access denied"})
        await websocket.close(code=1008)
        return

    # 3. Accept and Register
    await websocket.accept()
    
    progress_mgr = get_progress_manager(project)
    progress_mgr.register_listener(websocket)
    
    # Send initial success message
    await websocket.send_json({
        "type": "connected",
        "message": f"Authenticated as {user.email}. Monitoring project: {project.name}",
        "project_id": str(project.id)
    })

    # 4. Connection Loop
    try:
        while True:
            # We mostly wait for the ProgressManager to broadcast TO us,
            # but we listen for pings from the client to keep the connection alive
            try:
                data = await websocket.receive_json()
                
                if data.get("type") == "ping":
                    await websocket.send_json({"type": "pong"})
                
            except json.JSONDecodeError:
                # Ignore non-json messages
                continue
                
    except WebSocketDisconnect:
        # ProgressManager cleans up disconnected listeners automatically during broadcast
        print(f"Client disconnected from project {project_id}")
    except Exception as e:
        print(f"WebSocket error for project {project_id}: {e}")
    finally:
        # Optional: Manual cleanup if your ProgressManager doesn't handle it
        if websocket in progress_mgr.listeners:
            progress_mgr.listeners.remove(websocket)


@router.get("/projects/{project_id}/events")
async def get_progress_events(
    project_id: str,
    limit: int = 50,
    current_user: User = Depends(get_current_user)
):
    """
    Get historical progress events for a project
    """
    project = await Project.get_or_none(id=project_id, user=current_user)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    events = await ProgressEvent.filter(project=project).order_by("-created_at").limit(limit).all()
    
    return [
        {
            "id": str(e.id),
            "type": e.event_type.value,
            "message": e.message,
            "details": e.details,
            "current_step": e.current_step,
            "total_steps": e.total_steps,
            "percentage": e.percentage,
            "agent_name": e.agent_name,
            "timestamp": e.created_at.isoformat()
        }
        for e in events
    ]


@router.delete("/projects/{project_id}/events")
async def clear_progress_events(
    project_id: str,
    current_user: User = Depends(get_current_user)
):
    """
    Clear all progress events for a project
    """
    project = await Project.get_or_none(id=project_id, user=current_user)
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    await ProgressEvent.filter(project=project).delete()
    
    return {"message": "Progress events cleared"}
